%
% regslave.sl
% Registers load/save
%
% $Id: regslave.sl,v 1.3 2001/07/16 01:01:53 rocher Exp $
%

static variable Max_Registers = 95;  % The same as in 'register.sl'

%!%+
%\variable{Registers_File}
%\synopsis{Registers_File}
%\usage{String_Type Registers_File = "jed.reg";}
%\description
% The variable \var{Registers_File} is used by the function
% \var{registers_save} to know the file name in which to store all currently 
% defined registers. Its default value is "~/.jed-registers" under Unix and
% "~/jed.reg" on other platforms.
%\seealso{registers_load, registers_save}
%!%-
custom_variable( "Registers_File",
#ifdef UNIX
		 expand_filename( "~/.jed-registers" )
#elifdef VMS
		 "sys$login:jed.reg"
#else
		 expand_filename( "~/jed.reg" )
#endif
		 );

%!%+
%\function{registers_load}
%\synopsis{registers_load}
%\usage{Void_Type registers_load ();}
%\description
% This function reads a registers file, i.e. each line of the file is
% stored as a register. By default, registers are kept in a file whose name
% is stored in the \var{Registers_File} variable. This file is written in
% the current working directory associated with jed, i.e. the directory from
% which you started the jed process. For example, to read your registers file
% every time you start jed and give an alternative name to the registers file,
% put:
%#v+
%   if( BATCH == 0 )
%   {
%      custom_variable( Registers_File, ".my-jed-registers" );
%      registers_load();
%   }
%#v-
% in your .jedrc (or jed.rc) file. The \var{Registers_File} variable can be
% assigned either a file name or an absolute path+filename. In the first
% case, a file will be saved in the current working directory (the one
% you were in when you started jed), so you will find a registers file in
% every directory you work in. In the second one, only one file will be
% created, but you can handle 'local' registers files easily (see
% \var{registers_local_save} to know how to do it).
%\seealso{registers_save, registers_local_save, registers}
%\seealso{Registers_File}
%!%-
define registers_load ()
{
    % First look at the current working directory
    variable fp = fopen( path_concat( getcwd(),
                                      path_basename( Registers_File )), "r" );

    % If this didn't work, try using Registers_File.
    if( fp == NULL )
        fp = fopen( Registers_File, "r" );

    if( fp == NULL )
        return;

    variable reg = String_Type[Max_Registers];
    variable i, n, line;

    reg[*] = "";
    n = fgets( &line, fp );	% Skip first line (title)
    n = fgets( &line, fp );	% Read first register key
    while( n != -1 )
    {
        i = int( line ) - 32;
        n = fgets( &line, fp );
        while( andelse		% Read an entire, multi-line register
           { substr( line, 1, 1 ) == " " }
               { n != -1 } )
        {
            reg[i] += substr( line, 4, -1 );
            n = fgets( &line, fp );
        }
        % Delete last '\n' character
        reg[i] = substr( reg[i], 1, strlen( reg[i] )-1 );
    }
    () = fclose( fp );
    set_registers( reg );
}

%!%+
%\function{registers_save}
%\synopsis{registers_save}
%\usage{Int_Type registers_save ()}
%\description
% This function saves the contents of the registers array (see \var{registers_load}
% for more information) to the file specified by the variable \var{Registers_File}
% or to the local registers file (see \var{registers_local_save} for more
% information). It returns -1 upon failure, or 0 upon success.
%\notes
% When regslave.sl is loaded, \var{registers_save} will automatically get attached
% to the editors exit hooks.  As a result, it is really not necessary to call
% this function directly.
%\seealso{registers_load, registers_local_save}
%\seealso{Registers_File}
%!%-
define registers_save ()
{
    variable fp = NULL, file, st;

    if( _NARGS )
    {
        file = ();
        fp = fopen( file, "w" );
        if( fp == NULL )
        {
            verror( "Unable to open `%s' for writing.", file );
            return -1;
        }
    }
    else
    {
        file = path_concat( getcwd(), path_basename( Registers_File ));
        st = stat_file( file );
        if( st != NULL )
            fp = fopen( file, "w" );
        if( fp == NULL )
        {
            file = Registers_File;
            fp = fopen( file, "w" );
            if( fp == NULL )
            {
                verror( "Unable to open `%s' for writing.", file );
                return -1;
            }
        }
    }

    () = chmod( file, 0600 );

    variable i, reg = get_registers();
    i = 0;
    () = fprintf( fp, "%% JED: File generated by 'registers_save' on %s\n",
                  time() );
    loop( Max_Registers )
    {
        if( strlen( reg[i] ))
        {
            () = fprintf( fp, "%c\n", i+32 );
            () = fprintf( fp, "   %s\n",
                          strreplace( reg[i], "\n", "\n + ", strlen( reg[i] )));
        }
        ++i;
    }
    () = fclose( fp );

    return 0;
}

%!%+
%\function{registers_local_save}
%\synopsis{registers_local_save}
%\usage{Void_Type registers_local_save ()}
%\description
% This function saves all defined registers at some arbitrary file.
% If you give the same filename as in \var{Registers_File} but use a different
% path, then \var{registers_load} will load this registers set every
% time you start jed from that (and only from that) directory. This behavior is
% only useful when the value of \var{Registers_File} is an absoulte filename
% and you want local registers when you start jed from some specific directory.
%\seealso{registers_load, registers_save}
%\seealso{Registers_File}
%!%-
define registers_local_save ()
{
    variable file, st;

    file = read_with_completion( "Save local registers as:", "",
                                 path_basename( Registers_File ),
                                 'f');

    st = stat_file( file );

    if( st != NULL )
    {
        variable yn = get_y_or_n( "File `" + file + "' already exists, overwrite it" );
        if( yn <= 0 )
            error( "registers_local_save canceled." );
    }

    !if( registers_save( file ))
        flush( sprintf( "registers saved in '%s'", file ));
}

static define save_registers_at_exit ()
{
    () = registers_save();
    return 1;
}

add_to_hook( "_jed_exit_hooks", &save_registers_at_exit );
